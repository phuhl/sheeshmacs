#+TITLE: Starter Kit Defuns


This is part of the [[file:starter-kit.org][Emacs Starter Kit]].


* Hex-color-mode
#+begin_src emacs-lisp
  (defvar hexcolour-keywords
          '(("#[abcdefABCDEF[:digit:]]\\{3,6\\}"
             (0 (let ((colour (match-string-no-properties 0)))
                  (if (or (= (length colour) 4)
                          (= (length colour) 7))
                      (put-text-property
                       (match-beginning 0)
                       (match-end 0)
                       'face (list :background (match-string-no-properties 0)
                                   :foreground (if (>= (apply '+ (x-color-values 
                                                                  (match-string-no-properties 0)))
                                                       (* (apply '+ (x-color-values "white")) .6))
                                                   "black" ;; light bg, dark text
                                                 "white" ;; dark bg, light text
                                                )))))
                append))))
#+end_src

* The starter-kit-coding-hook:
A single hook holding those functions which should be run in *every*
code buffer.

We have a number of turn-on-* functions since it's advised that lambda
functions not go in hooks. Repeatedly evaling an add-to-list with a
hook value will repeatedly add it since there's no way to ensure that
a lambda doesn't already exist in the list.

#+name: starter-kit-hook-functions
#+begin_src emacs-lisp
(defvar starter-kit-coding-hook nil
"Hook that gets run on activation of any programming mode.")

(defun starter-kit-local-column-number-mode ()
  (make-local-variable 'column-number-mode)
  (column-number-mode t))

(defun starter-kit-local-comment-auto-fill ()
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))

(defun starter-kit-local-linum-mode ()
  (linum-mode t))

(defun starter-kit-turn-on-save-place-mode ()
  (setq save-place t))

(defun starter-kit-turn-on-whitespace ()
  (whitespace-mode t))

(defun stater-kit-turn-on-hex-color-mode ()
  (font-lock-add-keywords nil hexcolour-keywords t))
#+end_src


#+begin_src emacs-lisp
(add-hook 'starter-kit-coding-hook 'starter-kit-local-column-number-mode)
(add-hook 'starter-kit-coding-hook 'starter-kit-local-comment-auto-fill)
(add-hook 'starter-kit-coding-hook 'starter-kit-local-linum-mode)
(add-hook 'starter-kit-coding-hook 'starter-kit-turn-on-whitespace)
(add-hook 'starter-kit-coding-hook 'stater-kit-turn-on-hex-color-mode)
#+end_src

#+name: starter-kit-run-starter-kit-coding-hook
#+begin_src emacs-lisp
(defun run-starter-kit-coding-hook ()
  "Enable things that are convenient across all coding buffers."
  (run-hooks 'starter-kit-coding-hook))
#+end_src

* HS-Minor-Mode
#+BEGIN_SRC emacs-lisp
  (defun enable-hide-show-mode ()
                (local-set-key (kbd "C-c s") 'hs-show-block)
                (local-set-key (kbd "C-c a") 'hs-show-all)
                (local-set-key (kbd "C-c h") 'hs-hide-block)
                (local-set-key (kbd "C-c n") 'hs-hide-block)
                (hs-minor-mode t))
#+END_SRC

* Unique error names
Inserts a unique error name at place. Names are saved in the first
file named "errornames" found down the file-path.

#+begin_src emacs-lisp
(defun uerror ()
  (interactive)

  (setq target-file (concat (locate-dominating-file buffer-file-name "errornames") "errornames"))
  (setq line-count (length (with-temp-buffer
    (insert-file-contents target-file)
    (split-string (buffer-string) "\n" t))))

  (let ((error-name (concat "E" (number-to-string line-count))))
       (insert error-name)
       (write-region (concat error-name "\n") nil target-file 'append)))
#+end_src
