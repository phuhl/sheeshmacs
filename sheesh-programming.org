#+TITLE: Sheesh-Programming Config
#+DATE: [2020-12-09 Wed]
#+AUTHOR: Philipp Uhl
#+STARTUP: overview


* Setup for all Programming Modes

#+BEGIN_SRC emacs-lisp
  (set-default 'indent-tabs-mode nil)
  (set-default 'indicate-empty-lines t)
  (set-default 'tab-width 2)
  (set-default 'c-basic-offset 2)
  (set-default 'csharp-ts-mode-indent-offset 2)
#+END_SRC

** All purpose Coding Hook

A single hook holding those functions which should be run in *every*
code buffer.

We have a number of turn-on-* functions since it's advised that lambda
functions not go in hooks. Repeatedly evaling an add-to-list with a
hook value will repeatedly add it since there's no way to ensure that
a lambda doesn't already exist in the list.

#+BEGIN_SRC emacs-lisp
  (defvar sheesh-coding-hook nil
    "Hook that gets run on activation of any programming mode.")

  (defun sheesh-setup-coding-mode ()
    ;; local-column-number-mode
    (make-local-variable 'column-number-mode)
    (column-number-mode t)
    (display-line-numbers-mode t)

    ;; Comment auto fill mode, add line brakes in comments
    (set (make-local-variable 'comment-auto-fill-only-comments) t)
    (auto-fill-mode t)

    (editorconfig-mode 1)
    (setq save-place t)
    (whitespace-mode t)
    (rainbow-mode t)
    (rainbow-delimiters-mode t)
    (turn-on-smartparens-mode)
    (setq truncate-lines t)
    (font-lock-add-keywords major-mode
                            '(("\\(FIX\\|TODO\\|BUG\\|HACK\\|REFACTOR\\)"

                               1 font-lock-warning-face t))))


  (add-hook 'sheesh-coding-hook 'sheesh-setup-coding-mode)

  (defun run-sheesh-coding-hook ()
    "Enable things that are convenient across all coding buffers."
    (run-hooks 'sheesh-coding-hook))

#+END_SRC

** Whitespace mode

#+BEGIN_SRC emacs-lisp
  (setq
   whitespace-style '(
                      ;; Means, that a font face is used to highlight issues
                      face
                      ;; Means, when indent-tabs-mode
                      ;; - is t, ;; only spaces will be highlighted
                      ;; - is nil, ;; only tabs will be highlighted
                      indentation
                      ;; Other highlightable offenses:
                      trailing lines-tail)
   whitespace-line-column 80
   whitespace-global-modes '(not org-mode))
#+END_SRC

** Parentheses

**** Highlight matching parentheses when the point is on them.
#+srcname: sheesh-match-parens
#+begin_src emacs-lisp 
(show-paren-mode 1)
(custom-set-faces
 '(show-paren-match ((t (:inherit face-critical)))))
#+end_src

**** Rainbow parenthesis

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config)
#+END_SRC

** Editorconfig

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :ensure t
    :config
    ;; When tab mode is specified in editor config, should be able to
    ;; use our desired tab size as it is just a display issue. So let's
    ;; make sure, the correct tab size (2) is in use.
    (add-hook 'editorconfig-after-apply-functions
              (lambda (props)
                (if (and (gethash 'tab_width props) (gethash 'indent_size props))
                    (let ((indent-style (gethash 'indent_style props))
                      (indent-size (string-to-number (gethash 'indent_size props)))
                      (my-tab-width (string-to-number  (gethash 'tab_width props))))
                  (if (and (equal "tab" indent-style)
                           (/= my-tab-width 2)
                           (= 0 (mod indent-size 2)))
                   (progn
                     (editorconfig-set-indentation
                      indent-style
                      (number-to-string (/ indent-size 2))
                      "2")
                     (setq tab-width 2)))))))
    ;; Set correct line length for whitespace mode
    (add-hook 'editorconfig-after-apply-functions
              (lambda (props)
                (if (gethash 'max_line_length props)
                    (let ((line-length (string-to-number (gethash 'max_line_length props))))
                      (when (> line-length 0)
                        (setq whitespace-line-column line-length)))))))
#+END_SRC

** Structural Editing

Smartparens does a good job in some modes, but not in all. The new kid
in town is combobulate which is in alpha, not feature complete and not
available for all programming languages. But it is based on
tree-sitter, hence can be a lot more precise.

Let's use combobulate, where it is available and smartparens as a fallback.

**** Smartparens

-      Wrap something: =C-M-<space>= and e.g. =(=
-  Unwrap from within: =M-[= ......... =(|[abc])= -> =|[abc]=
- Unwrap from outside: =M-]= ......... =(|[abc])= -> =(|abc)=
-  Slurp to the right: =C-<right>= ... =(a b|) c= -> =(a b| c)=
-   Slurp to the left: =C-<left>= .... =a (b c|)= -> =(a b c|)=
-   Barf to the right: =M-<right>= ... =(a b c)= -> =(a b) c=
-    Barf to the left: =M-<left>= .... =(a b c)= -> =a (b c)=
-       Switch places: =C-M-t= ....... =a |b= -> =b a|=
- Split group:  ...... =(a b c d)= -> =(a b) | (c d)=
- Join groups: =C-M-g= ....... =(a b) | (c d)= -> =(a b c d)=

#+BEGIN_SRC emacs-lisp

  (use-package smartparens
    :ensure t
    :config
    (defun sheesh-sp-transpose-sexp ()
      (interactive)
      (sp-transpose-sexp)
      (sp-backward-sexp))
    (defun sheesh-sp-move-down-sexp ()
      (interactive)
      (sp-forward-sexp)
      (sheesh-sp-transpose-sexp))
    (defun sheesh-sp-move-up-sexp ()
      (interactive)
      (sheesh-sp-transpose-sexp)
      (sp-backward-sexp))
    (require 'smartparens-config)

    (add-hook
     'smartparens-mode-hook
     (lambda ()
       ;; Navigation
       (local-set-key (my-key "Forwards into sexp") 'sp-down-sexp)
       (local-set-key (my-key "Backwards into sexp") 'sp-backward-down-sexp)
       (local-set-key (my-key "Forwards out of sexp") 'sp-up-sexp)
       (local-set-key (my-key "Backwards out of sexp") 'sp-backward-up-sexp)
       (local-set-key (my-key "Go forward over sexp") 'sp-forward-sexp)
       (local-set-key (my-key "Go to start of next sexp") 'sp-next-sexp)
       (local-set-key (my-key "Go backwards over sexp") 'sp-backward-sexp)
       (local-set-key (my-key "Go to end of previous sexp") 'sp-previous-sexp)
       (local-set-key (my-key "Go to beginning of sexp") 'sp-beginning-of-sexp)
       (local-set-key (my-key "Go to ending of sexp") 'sp-end-of-sexp)


       ;; Manipulation
       (local-set-key (my-key "Unwrap previous sexp")
                      'sp-backward-unwrap-sexp)
       (local-set-key (my-key "Unwrap next sexp")
                      'sp-unwrap-sexp)
       (local-set-key (my-key "Slurp next sexp")
                      'sp-forward-slurp-sexp)
       (local-set-key (my-key "Slurp previous sexp")
                      'sp-backward-slurp-sexp)
       (local-set-key (my-key "Barf last sexp")
                      'sp-forward-barf-sexp)
       (local-set-key (my-key "Barf first sexp")
                      'sp-backward-barf-sexp)
       (local-set-key (my-key "Transpose previous and next sexp")
                      'sheesh-sp-transpose-sexp)
       (local-set-key (my-key "Kill next sexp")
                      'sp-kill-sexp)
       (local-set-key (my-key "Split (unGroup) sexp")
                      'sp-split-sexp)
       (local-set-key (my-key "Join (Group) sexp")
                      'sp-join-sexp)
       (local-set-key (my-key "Move sexp up/backwards")
                      'sheesh-sp-move-up-sexp)
       (local-set-key (my-key "Move sexp down/forwards")
                      'sheesh-sp-move-down-sexp))))
  ;; C-M-Space -> Mark whole sexp
  ;;(sp-local-pair '(web-mode) "<" ">" :actions nil)
  ;; (sp-cheat-sheet)
  ;;  (turn-on-smartparens-strict-mode)
#+END_SRC

**** Combobulate

- still in alpha
- Could be a Smartparens replacement for JSX and HTML
- Still missing lot's of features

#+BEGIN_SRC emacs-lisp
    (use-package combobulate
      :init
      ;; Remove default key map content. We want to set the keys ourselfs.
      ;; (setq combobulate-key-map (let ((map (make-sparse-keymap "Combobulate"))) map))
      :custom
        (combobulate-key-prefix "C-c o")

      :bind
      (:map combobulate-key-map
            ("M-n" . nil)
            ("M-p" . nil))

      :config
      ;; Jsx attributes will by default have {} instead of ""
      ;; autocompleted when typing =
      ;; Can also be set to nil to disable autocompleting the envelope
      (setq combobulate-js-ts-attribute-envelope-default "attr-expression")


      ;; (defhydra hydra-combobulate (:color blue :hint nil)
      ;;   "Combobulate"
      ;;   ("C-M-i" combobulate-navigate-down-list-maybe
      ;;    "Navigate In" :color red                              :column "Navigation")
      ;;   ("C-M-o" combobulate-navigate-up-list-maybe "Navigate Out" :color red      )
      ;;   ("C-M-n" combobulate-navigate-next "Navigate Next" :color red              )
      ;;   ("C-M-p" combobulate-navigate-previous "Navigate Prev" :color red          )
      ;;   ("C-M-f" combobulate-navigate-forward "Navigate Forward" :color red        )
      ;;   ("C-M-b" combobulate-navigate-backward "Navigate Backward" :color red      )
      ;;   ("" nil ""                                                                 )
      ;;   ("C-M-a" combobulate-navigate-beginning-of-defun "Beginning of defun"      )
      ;;   ("C-M-e" combobulate-navigate-end-of-defun "End of defun"                  )


      ;;   ("M-P" combobulate-drag-up "Drag backwards"   :column "Marking and Editing")
      ;;   ("M-N" combobulate-drag-down "Drag forwards"                               )
      ;;   ("" nil ""                                                                 )
      ;;   ("M-k" combobulate-kill-node-dwim "Kill Node DWIM"                         )
      ;;   ("SPC" combobulate-mark-node-dwim "Mark DWIM"                          )
      ;;   ("C-M-t" combobulate-transpose-sexps "Transpose nodes"                     )
      ;;   ("" nil ""                                                                 )
      ;;   ("s" sp-split-sexp "Split Group"                                           )
      ;;   ("j" sp-join-sexp "Join Group"                                             )
      ;;   ("u" combobulate-vanish-node "Unmantle JSX"                   :column "JSX")
      ;;   ("w" combobulate-envelop "Wrap"                                            )
      ;;   ("e" combobulate-edit-cluster-dwim "Edit node cluster"                                  )

      ;;   ("q" nil                                                   :column "Other"))
      ;; (add-hook
      ;;  'combobulate-mode-hook
      ;;  (lambda ()
      ;;    (local-set-key (my-key "Combobulate Hydra Prefix") 'hydra-combobulate/body)
      ;;    (local-set-key (my-key "Forwards into sexp") 'combobulate-navigate-down-list-maybe)
      ;;    (local-set-key (my-key "Backwards into sexp") 'combobulate-navigate-down-list-backward-maybe)

      ;;    (local-set-key (my-key "Forwards out of sexp") 'combobulate-navigate-up-list-backward-maybe)
      ;;    (local-set-key (my-key "Backwards out of sexp") 'combobulate-navigate-up-list-maybe)

      ;;    ;; Does not work right...
      ;;    ;; (local-set-key (my-key "Go forward over sexp") 'combobulate-navigate-forward)
      ;;    ;; (local-set-key (my-key "Go backwards over sexp") 'combobulate-navigate-backward)

      ;;    (local-set-key (my-key "Go to start of next sexp") 'combobulate-navigate-next)
      ;;    (local-set-key (my-key "Go to end of previous sexp") 'combobulate-navigate-previous)

      ;;    ;; No good equivalents as of now
      ;;    ;; (local-set-key (my-key "Backwards out of sexp") 'sp-backward-up-sexp)
      ;;    ;; (local-set-key (my-key "Go to beginning of sexp") ')
      ;;    ;; (local-set-key (my-key "Go to ending of sexp") 'sp-end-of-sexp)

      ;;    ;; Not great
      ;;    ;;(local-set-key (my-key "Mark expression") 'combobulate-mark-node-dwim)
      ;;    ))



      :load-path
      (lambda () (list (file-name-concat
                        (file-name-directory (or load-file-name (buffer-file-name)))
                        "src" "combobulate"))))
#+END_SRC

** Code hiding

#+BEGIN_SRC emacs-lisp
(defhydra hydra-hs-mode (:hint nil :color blue)
      "Collapse Region"
      ("b" hs-hide-block  "Hide block" )
      ("l" hs-hide-level  "Hide level" )
      ("TAB" hs-toggle-hiding  "Toggle region" )
      (">" hs-show-all  "Show all" )
      ("<" hs-hide-all  "Hide all" ))
#+END_SRC

** Colored Hex/color-named Colors

*** Hex-color-mode
#+BEGIN_SRC emacs-lisp
  (defvar hexcolour-keywords
    '(("#[abcdefABCDEF[:digit:]]\\{3,6\\}"
       (0 (let ((colour (match-string-no-properties 0)))
            (if (or (= (length colour) 4)
                    (= (length colour) 7))
                (put-text-property
                 (match-beginning 0)
                 (match-end 0)
                 'face
                 (list :background (match-string-no-properties 0)
                       :foreground
                       (if (>= (apply '+ (x-color-values
                                          (match-string-no-properties 0)))
                               (* (apply '+ (x-color-values "white")) .6))
                           "black" ;; light bg, dark text
                         "white" ;; dark bg, light text
                         )))))
          append))))
#+END_SRC

*** Rainbow-mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :config
    (setq rainbow-html-colors t))
#+END_SRC

** Yasnippet

#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :init
      (progn
        (add-hook 'after-save-hook
                  (lambda ()
                    (when (eql major-mode 'snippet-mode)
                      (yas-reload-all))))
        (setq yas-snippet-dirs (list (expand-file-name "snippets" sheeshmacs-dir)))
        (setq yas-prompt-functions '(yas/ido-prompt))
        (yas-global-mode 1)
        )
      :mode
      ("\\.yasnippet" . snippet-mode)
      :config
      (define-key yas-minor-mode-map (kbd "<tab>") nil)
      (define-key yas-minor-mode-map (kbd "TAB") nil)
      (define-key yas-minor-mode-map (kbd "<C-tab>")
        #'(lambda ()
           (interactive)
           (indent-for-tab-command)
           (yas-expand)))

      (define-key yas-keymap [(tab)]       nil)
      (define-key yas-keymap (kbd "TAB")   nil)
      (define-key yas-keymap [tab] nil)
      (define-key yas-keymap [(shift tab)] nil)
      (define-key yas-keymap [backtab]     nil)
      (define-key yas-keymap (my-key "_Yasnippet_ - Go to next field or expand") 
        'yas-next-field-or-maybe-expand)
      (define-key yas-keymap (my-key "_Yasnippet_ - Go to previous field") 'yas-prev-field))
#+END_SRC

*** Yasnippet with Org Mode

#+BEGIN_SRC emacs-lisp
  (defun yas/org-very-safe-expand ()
    (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

  (defun yas/org-setup ()
    ;; yasnippet (using the new org-cycle hooks)
    (make-variable-buffer-local 'yas/trigger-key)
    ;; (setq yas/trigger-key [tab])
    (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
    ;; (define-key yas/keymap [tab] 'yas/next-field)
    )

  ;; See https://github.com/eschulte/emacs24-starter-kit/issues/80.
  (setq org-src-tab-acts-natively nil)

  (add-hook 'org-mode-hook #'yas/org-setup)
#+END_SRC

*** Custom Yasnippet methods

#+BEGIN_SRC emacs-lisp
  (defun yas-delete (regexp)
    (goto-char yas-snippet-beg)
    (while (re-search-forward regexp yas-snippet-end t)
      (replace-match "")))

  (defun yas-delete-space ()
    (goto-char yas-snippet-beg)
    (delete-backward-char 1)
    (goto-char (- yas-snippet-end 1)))

  (defun yas-capitalize-first-char (&optional string)
    "Capitalize only the first character of the input STRING."
    (when (and string (> (length string) 0))
      (let ((first-char (substring string nil 1))
            (rest-str   (substring string 1)))
        (concat (capitalize first-char) rest-str))))
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
  (eval
   `(use-package magit
      :ensure t
      :defer t
      ;; :bind
      ;; (,(cons (my-bind "_Magit_ status") 'magit-status))
      :config
      (define-key magit-mode-map (kbd "TAB") 'magit-section-cycle)

      ;; Opens log buffer with all commits from me between two dates
      (defun magit-log-all-me-from-until ()
        (interactive)
        (magit-log-all-branches (list (concat "--since=\"" (org-read-date 'with-time) "\"")
                                      (concat "--until=\"" (org-read-date 'with-time) "\"")
                                      "--author=uhl")))))

#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC

** Prettify

#+BEGIN_SRC emacs-lisp
  ;; (use-package web-beautify :ensure t)


  ;; Uses prettier-js to beautify the current buffer
  (defun beautify-with-custom-buffer (file-extension)
    "Beautify the current buffer or region using prettier-js.

  Parameter FILE-EXTENSION: The file extension of the buffer to beautify. It defines the
    prettier-js parser to use.

  Requires `prettier-js' to be installed."
    (setq prev-buffer (current-buffer))
    (setq prev-point (point))
    (setq prev-mark (mark))
    (setq temp-buffer (generate-new-buffer "*beautify-temp-buffer*"))
    (if (use-region-p)
        (copy-region-as-kill (region-beginning) (region-end))
      (copy-region-as-kill (point-min) (point-max)))
    (switch-to-buffer temp-buffer)
    (cd user-emacs-directory)
    (yank)
    (setq buffer-file-name (concat (make-temp-name "beautify") file-extension))
    (prettier-js)
    (setq buffer-file-name nil)
    (switch-to-buffer prev-buffer)
    (if (use-region-p)
        (delete-region (region-beginning) (region-end))
      (delete-region (point-min) (point-max)))
    (insert-buffer-substring temp-buffer)
    (kill-buffer temp-buffer)
    (goto-char prev-point)
    (set-mark prev-mark))


  (defun beautify-xml ()
    (interactive)
    (beautify-with-custom-buffer ".xml"))

  (defun beautify-html ()
    (interactive)
    (beautify-with-custom-buffer ".html"))

  (defun beautify-js ()
    (interactive)
    (beautify-with-custom-buffer ".js"))

  (defun beautify-json ()
    (interactive)
    (beautify-with-custom-buffer ".json"))

  (defun beautify-css ()
    (interactive)
    (beautify-with-custom-buffer ".css"))

  (defun beautify-sql ()
    (interactive)
    (beautify-with-custom-buffer ".sql"))

#+END_SRC

** Faster Macros

Sometimes I need to modify a lot of files. Usually, I start with a
list of files from compilation mode or in dired. I create a macro to
go to the file in line 1, do changes, save the file, move to the next
line in the original buffer. Repeat.

This is very slow when there are lot's of hooks on the mode of the
buffer to be changed. To prevent these hooks to run, you can use
=macro-setup= to change file opening to literal mode and =macro-teardown=
to change it back afterwards. This affects compilation mode and dired
mode.

#+BEGIN_SRC emacs-lisp
  (setq is-in-macro-mode nil)
  (defun macro-setup ()
    "Modify file opening in compilation mode to open files literally.

  Can be undone with `teardown-after-macro'."
    (interactive)
    (setq is-in-macro-mode t))

  (defun macro-teardown ()
    (interactive)
    (setq is-in-macro-mode nil))
#+END_SRC

*** Overwritten Functions

To ensure functioning of faster macros, we need to modify some
functions and make them open files differently depending on =is-=in-macro-mode=.

**** Dired

Modified =dired-find-file= function checks for =is-=in-macro-mode= first to
see how to open a file.

#+BEGIN_SRC emacs-lisp
  (setf dired-find-file-orig (symbol-function #'dired-find-file))
  (defun dired-find-file ()
    "In Dired, visit the file or directory named on this line in literal mode."
    (interactive)
    (if is-in-macro-mode
        (dired--find-file #'find-file-literally (dired-get-file-for-visit))
      (funcall dired-find-file-orig)))
#+END_SRC

**** Compilation mode

Modified =compilation-find-file= function: Nearly an exact copy of the
original, but with different calls to open a file.

#+BEGIN_SRC emacs-lisp
  (setf compilation-find-file-orig (symbol-function #'compilation-find-file))
  (defun compilation-find-file (marker filename directory &rest formats)
    (if (not is-in-macro-mode)
        (apply compilation-find-file-orig marker filename directory formats)
      (or formats (setq formats '("%s")))
      (let ((dirs compilation-search-path)
            (spec-dir (if directory
                          (expand-file-name directory)
                        default-directory))
            buffer thisdir fmts name)
        (if (and filename
                 (file-name-absolute-p filename))
            ;; The file name is absolute.  Use its explicit directory as
            ;; the first in the search path, and strip it from FILENAME.
            (setq filename (abbreviate-file-name (expand-file-name filename))
                  dirs (cons (file-name-directory filename) dirs)
                  filename (file-name-nondirectory filename)))
        ;; Now search the path.
        (while (and dirs (null buffer))
          (setq thisdir (or (car dirs) spec-dir)
                fmts formats)
          ;; For each directory, try each format string.
          (while (and fmts (null buffer))
            (setq name (file-truename
                        (file-name-concat thisdir (format (car fmts) filename)))
                  buffer (and (file-exists-p name)
                              (find-file-noselect name nil t))
                  fmts (cdr fmts)))
          (setq dirs (cdr dirs)))
        ;; If we haven't found it, this might be a parallel build.
        ;; Search the directories further up the buffer.
        (when (and (null buffer)
                   compilation-search-all-directories)
          (with-current-buffer (marker-buffer marker)
            (save-excursion
              (goto-char (marker-position marker))
              (when-let ((prev (compilation--previous-directory (point))))
                (goto-char prev))
              (setq dirs (cdr (or (get-text-property
                                   (1- (point)) 'compilation-directory)
                                  (get-text-property
                                   (point) 'compilation-directory))))))
          (while (and dirs (null buffer))
            (setq thisdir (car dirs)
                  fmts formats)
            (while (and fmts (null buffer))
              (setq name (file-truename
                          (file-name-concat thisdir (format (car fmts) filename)))
                    buffer (and (file-exists-p name)
                                (find-file-noselect name nil t))
                    fmts (cdr fmts)))
            (if (null buffer)
                (message "2 is null")
              (message "2 is not null"))
            (setq dirs (cdr dirs))))
        (while (null buffer)    ;Repeat until the user selects an existing file.
          ;; The file doesn't exist.  Ask the user where to find it.
          (save-excursion            ;This save-excursion is probably not right.
            (let ((w (let ((pop-up-windows t))
                       (display-buffer (marker-buffer marker)
                                       '(nil (allow-no-window . t))))))
              (with-current-buffer (marker-buffer marker)
                (goto-char marker)
                (and w (progn (compilation-set-window w marker)
                              (compilation-set-overlay-arrow w))))
              (let* ((name (read-file-name
                            (format-prompt "Find this %s in"
                                           filename compilation-error)
                            spec-dir filename t nil
                            ;; The predicate below is fine when called from
                            ;; minibuffer-complete-and-exit, but it's too
                            ;; restrictive otherwise, since it also prevents the
                            ;; user from completing "fo" to "foo/" when she
                            ;; wants to enter "foo/bar".
                            ;;
                            ;; Try to make sure the user can only select
                            ;; a valid answer.  This predicate may be ignored,
                            ;; tho, so we still have to double-check afterwards.
                            ;; TODO: We should probably fix read-file-name so
                            ;; that it never ignores this predicate, even when
                            ;; using popup dialog boxes.
                            ;; (lambda (name)
                            ;;   (if (file-directory-p name)
                            ;;       (setq name (expand-file-name filename name)))
                            ;;   (file-exists-p name))
                            ))
                     (origname name))
                (cond
                 ((not (file-exists-p name))
                  (message "Cannot find file `%s'" name)
                  (ding) (sit-for 2))
                 ((and (file-directory-p name)
                       (not (file-exists-p
                             (setq name (file-truename
                                         (file-name-concat name filename))))))
                  (message "No `%s' in directory %s" filename origname)
                  (ding) (sit-for 2))
                 (t
                  (setq buffer (find-file-noselect name nil t))))))))
        ;; Make intangible overlays tangible.
        ;; This is weird: it's not even clear which is the current buffer,
        ;; so the code below can't be expected to DTRT here.  -- Stef
        (dolist (ov (overlays-in (point-min) (point-max)))
          (when (overlay-get ov 'intangible)
            (overlay-put ov 'intangible nil)))
        buffer)))

#+END_SRC

** Base64

The inbuild =base64-decode-string= function, when called interactively
does not work on all base64 strings. You need to pass =t= as second
parameter to make it use RFC 4648 decoding. This function wraps it in
such a way that it uses RFC 4648 decoding.

#+BEGIN_SRC emacs-lisp
  (defun decode-base64-region (start end)
    (interactive "r")
    (replace-string-in-region
     (buffer-substring start end)
     (base64-decode-string (buffer-substring start end) t)
     start end))
#+END_SRC

** Auto complete

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure
    :custom
    (company-idle-delay 0.5) ;; how long to wait until popup
    ;; (company-begin-commands nil) ;; uncomment to disable popup
    :config
    (add-hook
     'company-mode-hook
     #'(lambda ()
         (local-set-key (my-key "Autocomplete")
                        'company-indent-or-complete-common)))

    :bind
    (:map company-active-map
          ("C-n". company-select-next)
          ("C-p". company-select-previous)
          ("M-<". company-select-first)
          ("M->". company-select-last)))

  (use-package company-box
    :ensure
    :hook (company-mode . company-box-mode))
#+END_SRC

** Autocomplete UI

#+BEGIN_SRC emacs-lisp
  (eval `(defhydra hydra-autocomplete
           (global-map ,(my-bind "Auto complete hydra") :hint nil :color blue)
           "Complete"
           ("c" copilot-accept-completion "Accept" :column "Copilot")
           ("w" copilot-accept-completion-by-word "Accept by Word" :color red)
           ("C-c" copilot-complete "Show completion")
           ("C" hydra-copilot/body "Copilot")

           ("s" yas-next-field-or-maybe-expand "Snippet" :column "Yas")

           ("h" hydra-autocomplete/body "Help" :column nil)
           ("?" hydra-autocomplete/body "Help" :column nil)))




  (defun bind-custom-tab-hydra (custom-completions mode-name mode-keymap)
    (eval `(defhydra ,(intern (concat "hydra-autocomplete-" mode-name))
             (mode-keymap ,(my-bind "Auto complete hydra") :hint nil :color blue :timeout 3)
             "Complete"
             ("c" copilot-accept-completion "Accept" :column "Copilot")
             ("w" copilot-accept-completion-by-word "Accept by Word" :color red)
             ("C-c" copilot-complete "Show completion")
             ("C" hydra-copilot/body "Copilot")

             ("s" yas-next-field-or-maybe-expand "Snippet" :column "Yas")

             ("h" ,(intern (concat "hydra-autocomplete-" mode-name "/body")) "Help" :column nil)
             ("?" ,(intern (concat "hydra-autocomplete-" mode-name "/body")) "Help" :column nil)

             ,@(mapcar (lambda (x)
                         (list (car x) (cadr x) (caddr x) :column (cadddr x)))
                       custom-completions)))
    ;; Important to use define-key instead of local-set-key because the
    ;; hydra will not show up if using define-key, which allows stuff
    ;; like copilot to work
    (define-key mode-keymap (my-key "Auto complete hydra") (intern (concat "hydra-autocomplete-" mode-name "/body"))))

  ;; Usage:

  ;; (bind-custom-tab-hydra
  ;;  '(("f" . ( company-files "Files" "Company")))
  ;;  "test")
#+END_SRC

** LSP

#+BEGIN_SRC emacs-lisp
    (use-package lsp-mode
      :ensure t
      :commands lsp
      :init
      ;; (setq lsp-keymap-prefix "C-; l") Conflicts with C-; hydra, if
      ;; needed in future, re assign to something else
      :custom
      (lsp-eldoc-render-all t)
      (lsp-idle-delay 0.6)
      ;; enable / disable the hints as you prefer:
      (lsp-rust-analyzer-server-display-inlay-hints t)
      (lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
      (lsp-rust-analyzer-display-chaining-hints t)
      (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
      (lsp-rust-analyzer-display-closure-return-type-hints t)
      (lsp-rust-analyzer-display-parameter-hints nil)
      (lsp-rust-analyzer-display-reborrow-hints nil)
      :config

      ;; https://github.com/emacs-lsp/lsp-mode/issues/4773
      (lsp-make-interactive-code-action remove-unused-imports "source.removeUnusedImports")

      (defun lsp-organize-and-remove-unused-imports ()
        (interactive)
        (lsp-organize-imports)
        (lsp-remove-unused-imports))
        (lsp-make-interactive-code-action rename-file "source.applyRenameFile")


      (add-hook 'lsp-mode-hook 'lsp-ui-mode)
      (defhydra hydra-lsp-mode (:hint nil :color blue)
        "LSP Mode"
        ("C-S-SPC" lsp-signature-activate "Show function signature" :column "Show")

        ("X" lsp-workspace-restart "Restart LSP" :column "Server")
        ("d" lsp-describe-session "Describe Session")
        ("R" lsp-workspace-restart "Restart Workspace")

        ("a" lsp-workspace-folders-add "Folders add" :column "Workspace")
        ("b" lsp-workspace-blacklist-remove "Blacklist remove")
        ("r" lsp-workspace-folders-remove "Folders remove")

        ("S" lsp-ui-sideline-mode           "Ui Sideline Mode" :column "Toggle")
        ("M" lsp-modeline-diagnostics-mode  "Modeline Diagnostics Mode" )
        ("L" lsp-toggle-trace-io            "Toggle Trace Io")
        ("A" lsp-modeline-code-actions-mode "Modeline Code Actions Mode")
        ("B" lsp-headerline-breadcrumb-mode "Headerline Breadcrumb Mode")
        ("D" lsp-ui-doc-mode                "Ui Doc Mode")
        ("h" lsp-toggle-symbol-highlight    "Toggle Symbol Highlight")
        ("l" lsp-lens-mode                  "Lens Mode")))

    (use-package lsp-ui
      :ensure
      :commands lsp-ui-mode
      :custom
      (lsp-ui-peek-always-show t)
      (lsp-ui-sideline-show-hover nil)
      (lsp-ui-sideline-enable nil)
      (lsp-ui-doc-enable nil)
      (lsp-headerline-breadcrumb-enable nil))
  (use-package lsp-ivy :ensure :commands lsp-ivy-workspace-symbol)

  (use-package ivy-xref
    :ensure t
    :init
    ;; xref initialization is different in Emacs 27 - there are two different
    ;; variables which can be set rather than just one
    (when (>= emacs-major-version 27)
      (setq xref-show-definitions-function #'ivy-xref-show-defs))
    ;; Necessary in Emacs <27. In Emacs 27 it will affect all xref-based
    ;; commands other than xref-find-definitions (e.g. project-find-regexp)
    ;; as well
    (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

** Debugging with DAP-mode

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  ;; Uncomment the config below if you want all UI panes to be hidden by default!
  ;; :custom
  ;; (lsp-enable-dap-auto-configure nil)
  ;; :config


  :config
  (dap-ui-mode 1)
  ;; Set up Node debugging
  (require 'dap-node)
  (require 'dap-netcore)
  ;;(dap-node-setup) ;; Automatically installs Node debug adapter if needed
)
#+END_SRC

** Tree Sitter

#+BEGIN_SRC emacs-lisp
  (use-package treesit
    :commands (treesit-install-language-grammar nf/treesit-install-all-languages)
    :init
    (setq treesit-language-source-alist
     '((bash . ("https://github.com/tree-sitter/tree-sitter-bash"))
       (c . ("https://github.com/tree-sitter/tree-sitter-c"))
       (cpp . ("https://github.com/tree-sitter/tree-sitter-cpp"))
       (css . ("https://github.com/tree-sitter/tree-sitter-css"))
       (c-sharp . ("https://github.com/tree-sitter/tree-sitter-c-sharp"))
       (go . ("https://github.com/tree-sitter/tree-sitter-go"))
       (html . ("https://github.com/tree-sitter/tree-sitter-html"))
       (javascript . ("https://github.com/tree-sitter/tree-sitter-javascript"))
       (json . ("https://github.com/tree-sitter/tree-sitter-json"))
       (lua . ("https://github.com/Azganoth/tree-sitter-lua"))
       (make . ("https://github.com/alemuller/tree-sitter-make"))
       (ocaml . ("https://github.com/tree-sitter/tree-sitter-ocaml" "ocaml/src" "ocaml"))
       (python . ("https://github.com/tree-sitter/tree-sitter-python"))
       (php . ("https://github.com/tree-sitter/tree-sitter-php"))
       (typescript . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src"))
       (tsx . ("https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src"))
       (ruby . ("https://github.com/tree-sitter/tree-sitter-ruby"))
       (rust . ("https://github.com/tree-sitter/tree-sitter-rust"))
       (sql . ("https://github.com/m-novikov/tree-sitter-sql"))
       (toml . ("https://github.com/tree-sitter/tree-sitter-toml"))
       (zig . ("https://github.com/GrayJack/tree-sitter-zig"))))
    :config
    (defun nf/treesit-install-all-languages ()
      "Install all languages specified by `treesit-language-source-alist'."
      (interactive)
      (let ((languages (mapcar 'car treesit-language-source-alist)))
        (dolist (lang languages)
          (treesit-install-language-grammar lang)
          (message "`%s' parser was installed." lang)
          (sit-for 0.25)))))
#+END_SRC

** UUID

#+BEGIN_SRC emacs-lisp
  (defun uuid ()
    (let ((xstr (md5 (format "%s%s%s%s%s%s%s%s%s%s"
                                (user-uid)
                                (emacs-pid)
                                (system-name)
                                (user-full-name)
                                (current-time)
                                (emacs-uptime)
                                (garbage-collect)
                                (buffer-string)
                                (random)
                                (recent-keys)))))
      ( format "%s-%s-4%s-%s%s-%s"
        (substring xstr 0 8)
        (substring xstr 8 12)
        (substring xstr 13 16)
        (format "%x" (+ 8 (random 4)))
        (substring xstr 17 20)
        (substring xstr 20 32))))

  (uuid)


  (defun insert-uuid ()
    "Insert a UUID."
    (interactive)
    (insert (uuid)))
#+END_SRC

** Programming Mode Hydras

#+BEGIN_SRC emacs-lisp
(defhydra hydra-prog-mode-search (:hint nil :color blue)
      "Find"
      ("s" lsp-ivy-workspace-symbol "Find symbol in file" :column "LSP")
      ("S" lsp-ivy-global-workspace-symbol "Find symbol in project")
      ("M" lsp-ui-imenu "Show symbols in file")
      ("g" counsel-git-grep "Grep in current project" :column "Git")
      ("f" counsel-git "Find file in project"))
#+END_SRC
(display-fn-in-window 'counsel-git-grep)

** Copilot

#+BEGIN_SRC emacs-lisp
  ;;(use-package copilot
  ;;  :vc (:url "https://github.com/copilot-emacs/copilot.el"
  ;;            :rev :newest
  ;;            :branch "main")
  ;;            :hook (prog-mode . copilot-mode)
  ;;            )
  ;;
  (use-package copilot
    :load-path (lambda ()
                 (list (file-name-concat
                        user-emacs-directory
                        "src" "copilot" "copilot.el" "copilot.el")))
    :hook (prog-mode . copilot-mode))


  (defhydra hydra-copilot (:color blue :hint nil)
    "Copilot"
    ("TAB" copilot-complete "Complete" :column "Sugest" :color red)

    ("c" copilot-accept-completion "Accept" :column "Completion")
    ("w" copilot-accept-completion-by-word "Accept by Word" :color red)
    ("n" copilot-next-completion "Next completion" :color red)
    ("p" copilot-previous-Completion "Prev completion" :color red))
#+END_SRC

** Indentation guides

To be enabled by the programing language specific mode.

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :init
    (setq highlight-indent-guides-method 'fill)
    (setq highlight-indent-guides-responsive nil)
    (setq highlight-indent-guides-delay 0)
    :ensure t)
#+END_SRC
* Language Specific

** Lisp

#+BEGIN_SRC emacs-lisp
  (global-set-key (my-key "Run lisp and replace with result") 'eval-and-replace)
  (add-hook 'lisp-mode-hook 'sheesh-turn-on-smartparen-mode)
#+END_SRC

** Prolog

#+BEGIN_SRC emacs-lisp
  (add-hook 'prolog-mode-hook
            (lambda ()
              (local-set-key (my-key "Prolog Dwim") 'ediprolog-dwim)
              (run-sheesh-coding-hook)))
#+END_SRC

** Graphql mode

#+BEGIN_SRC emacs-lisp
  (use-package graphql-mode
    :ensure t)
#+END_SRC

** Haskell

- Pretty lambdas in Haskell code
  #+BEGIN_SRC emacs-lisp
    (defun pretty-lambdas-haskell ()
      (font-lock-add-keywords
       nil `((,(concat "(?\\(" (regexp-quote "\\") "\\)")
              (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                        ,(make-char 'greek-iso8859-7 107))
                        nil))))))
  #+END_SRC

*** Haskell Mode

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :defer t
    :config
    (add-hook 'haskell-mode-hook 'run-sheesh-coding-hook)
    (when (window-system)
      (add-hook 'haskell-mode-hook 'pretty-lambdas-haskell))
    (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
    (add-hook 'haskell-mode-hook 'flyspell-prog-mode)
    (add-hook 'haskell-mode-hook 'haskell-indentation-mode)
    (add-hook 'haskell-mode-hook #'lsp)
    (add-hook 'haskell-literate-mode-hook #'lsp)

    (defhydra hydra-haskell-mode (:hint nil :color blue)
      ("L" hydra-lsp-mode/body "LSP")
      ("E" lsp-treemacs-errors-list "Project errors"    :column "Show")
      ("d" lsp-describe-thing-at-point "Doc at point")
      ("." xref-find-definitions-other-window "Goto Definition (other buf)")
      ("," lsp-find-references "References")
      ("?" lsp-find-type-definition "Type definition")
      ("r" lsp-rename "Rename item"                     :column "Refactor")
      ("i" lsp-organize-imports "Organize imports")
      ("P" lsp-format-buffer "Prettify buffer"          :column "Do")
      ("p" lsp-format-region "Prettify region")
      ("s" sp-split-sexp "Split Group"                  :column "Edit")
      ("j" sp-join-sexp "Join Group"))

    (defun setup-haskell-mode ()
      (local-set-key (my-key "Mode hydra") 'hydra-haskell-mode/body))
    (add-hook 'haskell-mode-hook 'setup-haskell-mode))



  ;; Ignore compiled Haskell files in filename completions
  (add-to-list 'completion-ignored-extensions ".hi")
#+END_SRC

*** Intero Mode

#+BEGIN_SRC emacs-lisp
;; it appears as if intero was discontinued
;;(use-package intero
;;  :ensure t
;;  :defer t
;;  :init
;;  (add-hook 'haskell-mode-hook 'intero-mode))
#+END_SRC

** Java

*** Java Mode

#+BEGIN_SRC emacs-lisp
  (defun my-indent-setup ()
    (c-set-offset 'arglist-intro '++)
    (c-set-offset 'arglist-cont '0)
    (c-set-offset 'arglist-cont-nonempty 'c-lineup-arglist))
  (add-hook 'java-mode-hook 'run-sheesh-coding-hook)
  (add-hook 'java-mode-hook 'my-indent-setup)
  (add-hook 'java-mode-hook 'enable-hide-show-mode)
#+END_SRC

*** Java-beautifier
#+BEGIN_SRC emacs-lisp
  (autoload 'beautify-java "beautify-java" "A java beautifier" t)
#+END_SRC

** Lisp

*** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'run-sheesh-coding-hook)
  (add-hook 'emacs-lisp-mode-hook 'starter-kit-remove-elc-on-save)
  (add-hook 'emacs-lisp-mode-hook 'highlight-indent-guides-mode)
  ;;  (add-hook 'emacs-lisp-mode-hook 'idle-highlight)
  ;;  (add-hook 'emacs-lisp-mode-hook 'turn-on-paredit)
  (define-key emacs-lisp-mode-map (kbd "C-c v") 'eval-buffer)

  (defun starter-kit-remove-elc-on-save ()
    "If you're saving an elisp file, likely the .elc is no longer valid."
    (make-local-variable 'after-save-hook)
    (add-hook 'after-save-hook
              (lambda ()
                (if (file-exists-p (concat buffer-file-name "c"))
                    (delete-file (concat buffer-file-name "c"))))))

#+END_SRC
*** Eval and Replace

#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (global-set-key (my-key "Run lisp and replace with result") 'eval-and-replace)
#+END_SRC

*** Common Lisp

#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-mode-hook 'run-sheesh-coding-hook)
#+END_SRC
** Python

Issues?
- =peculiar error: "exited abnormally with code 1"= :: Try running =M-x elpy-rpc-reinstall-virtualenv=

#+BEGIN_SRC emacs-lisp
(use-package python
  :ensure t
  :defer t
  :mode ("\\.py\\'" . python-mode)
  :config
    (add-hook 'python-mode-hook 'highlight-indent-guides-mode))

(use-package elpy
  :ensure t
  :after python
  :config
  (elpy-enable)
  (add-hook 'elpy-mode-hook 'run-sheesh-coding-hook)
  (setq indent-tabs-mode nil
        tab-width 4
        python-indent-offset 4)
  (setq-default python-indent 4))
#+END_SRC
** CSS

#+BEGIN_SRC emacs-lisp
  (add-hook 'css-mode-hook 'run-sheesh-coding-hook)
#+END_SRC
** CSV

#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :ensure t
    :defer t
    :config
    (defhydra hydra-csv-mode (:hint nil :color blue)
      "CSV"
      ("s" csv-sort-fields "Sort fields" :column "Display")
      ("n" csv-sort-numeric-fields "Sort numberic fields" )
      ("a" csv-align-fields "Align fields" )
      ("u" csv-unalign-fields "Unalign fields" )
      ("t" csv-transpose "Transpose" )

      ("k" csv-kill-fields "Kill fields" :column "Edit" )
      ("y" csv-yank-fields "Yank fields" )
      ("r" csv-reverse-region "Reverse region" )

      (";" csv-set-separator "Set Separator" :column "Setup" ))
    (defun setup-csv-mode ()
      (local-set-key (my-key "Mode hydra") 'hydra-csv-mode/body))
    (add-hook 'csv-mode-hook 'setup-csv-mode))
#+END_SRC

** JS

#+BEGIN_SRC emacs-lisp
  (use-package js-doc
    :ensure t
    :defer t)
#+END_SRC

*** RJSX mode / React

#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :ensure t
    :mode ("\\.c?m?js$" . rjsx-mode)
    :interpreter ("node" . rjsx-mode)
    :init
    ;; Set indentation to 2 spaces
    (setq rjsx-basic-offset 2)
    (custom-set-variables
     '(js-indent-level 2))

    :config
    (add-hook 'tsx-ts-mode-hook 'emmet-mode)
    (add-hook 'rjsx-mode-hook 'run-sheesh-coding-hook)
    (add-hook 'rjsx-mode-hook 'flycheck-mode)
    (add-hook 'rjsx-mode-hook
              #'(lambda ()
                 (setup-cycle-quotes)
                 (define-key rjsx-mode-map
                   (my-key "JS Doc insert function doc")
                   'js-doc-insert-function-doc)
                 (define-key rjsx-mode-map
                   (my-key "JS DOc insert tag")
                   'js-doc-insert-tag))))
#+END_SRC

*** Vue

#+BEGIN_SRC emacs-lisp
    ;; for completions
    ;; it appears as company-lsp was discontinued
    ;;  (use-package company-lsp
;;      :ensure t
;;      :after lsp-mode
;;      :config (push 'company-lsp company-backends))

  (use-package vue-mode
      :mode "\\.vue\\'"
      :ensure t
      :config
      (add-hook 'vue-mode-hook #'lsp)
      (add-hook 'vue-mode-hook #'prettier-js-mode)
      (add-hook 'vue-mode-hook 'run-sheesh-coding-hook))
#+END_SRC

*** Prettier

To install prettier on your system you have to manually run:
#+BEGIN_SRC sh
cd ~/.emacs.d
npm i
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (use-package prettier-js
    :load-path
    (lambda () (list (file-name-concat
                      (file-name-directory (or load-file-name (buffer-file-name)))
                      "src" "prettier-js.el")))
    :commands prettier-js
    :hook ((web-mode
            rjsx-mode
            typescript-ts-mode
            tsx-ts-mode
            json-mode
            yaml-ts-mode
            glsl-mode
            yaml-mode)
           . prettier-js-mode))
#+END_SRC

*** Tern

Once in a while it can be usefull to restart tern.

#+BEGIN_SRC emacs-lisp
    ;; it appears as company-tern was discontinued
;;  (eval
;;   `(use-package company-tern
;;    :ensure t
;;    :defer t
;;    :bind
;;    (,(cons (my-bind "Accept tern suggestion") 'company-tern))
;;
;;    :config
;;    (add-to-list 'company-backends 'company-tern)))



;;  (defun delete-tern-process ()
;;    (interactive)
;;    (delete-process "Tern"))
;;
;;  (add-hook 'rjsx-mode-hook (lambda ()
;;                              (auto-complete-mode 0)
;;                              (company-mode)
;;                              (tern-mode)))
;;  (add-hook 'web-mode-hook (lambda ()
;;                              (auto-complete-mode 0)
;;                              (company-mode)
;;                              (tern-mode)))
;;
;;  (use-package tern
;;    :defer t
;;    :ensure t
;;    :config
;;    (eval-after-load 'tern
;;      '(progn (require 'company-tern)))
;;    )
#+END_SRC

*** Spellchecking in JS

#+BEGIN_SRC emacs-lisp
  ;; disable jshint since we prefer eslint checking
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(javascript-jshint)))

  ;; disable json-jsonlist checking for json files
  (setq-default flycheck-disabled-checkers
                (append flycheck-disabled-checkers
                        '(json-jsonlist)))


  ;; use eslint with web-mode for jsx files
  (defun my/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
  (flycheck-add-mode 'javascript-eslint 'rjsx-mode)
#+END_SRC

*** ESLint Fix

#+BEGIN_SRC emacs-lisp
  (use-package eslint-fix
    :ensure t)
  (defun js-fix ()
    (interactive)
    (setq eslint-fix-executable (my/use-eslint-from-node-modules))
    (eslint-fix))
#+END_SRC

*** EsLint Compile Mode

Adds a parser to compilation mode to support eslint output.

#+BEGIN_SRC emacs-lisp
(require 'compile-eslint)
(push 'eslint compilation-error-regexp-alist)
#+END_SRC

*** Cycle Quotes

#+BEGIN_SRC emacs-lisp
  (use-package cycle-quotes
    :ensure t)
  (defun setup-cycle-quotes ()
    (setq cycle-quotes--quote-chars '(34 96 39))
    (local-set-key (my-key "Cycle quotes")
                   'cycle-quotes))
#+END_SRC

** HTML

*** Emmet mode

[[https://github.com/smihica/emmet-mode][Emmet-Mode]] is pretty sweet, but need to hook it up to both SGML (which
includes HTML) and CSS.

Use =C-j= to expand emmet-code to html/css code.

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :commands emmet-mode
    :init
    (setq emmet-indentation 2)
    (setq emmet-move-cursor-between-quotes t)
    :config

    ;; Add _ as alternative syntax for > (child) to make it work with
    ;; smartparens-strict-mode.
    (defun emmet-child-sans (parent input)
      (emmet-parse "[>_]" 1 ">"
                   (emmet-run emmet-subexpr
                              it
                              '(error "expected child"))))
    (defun emmet-child (parent input)
      (emmet-parse "[>_]" 1 ">"
                   (emmet-run emmet-subexpr
                              (let ((child expr))
                                (emmet-aif (emmet-regex "^" input '(0 1))
                                           (let ((input (elt it 1)))
                                             (emmet-run emmet-subexpr
                                                        `((sibling (parent-child ,parent ,child) ,expr) . ,input)
                                                        `((parent-child ,parent ,child) . ,input)))
                                           `((parent-child ,parent ,child) . ,input)))
                              '(error "expected child"))))
    (add-hook 'sgml-mode-hook 'emmet-mode)
    (add-hook 'css-mode-hook  'emmet-mode)
    (add-hook 'web-mode-hook  'emmet-mode))
#+END_SRC

*** Web mode

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :mode (
           ("\\.phtml\\'" . web-mode)
           ("\\.tpl\\.php\\'" . web-mode)
           ("\\.[agj]sp\\'" . web-mode)
           ("\\.as[cp]x\\'" . web-mode)
           ("\\.erb\\'" . web-mode)
           ("\\.mustache\\'" . web-mode)
           ("\\.njk\\'" . web-mode)
           ("\\.djhtml\\'" . web-mode)
           ("\\.html?\\'" . web-mode)
;;           ("\\.cjs$" . web-mode)
;;           ("\\.js$" . web-mode)
;;           ("\\.mjs$" . web-mode)
;;           ("\\.jsx\\'" . web-mode)
           ("\\.ftl\\'" . web-mode))
    :config
    (setq web-mode-enable-front-matter-block t)

    (defun pretify-afterwards (fun)
      (interactive)
      (funcall fun)
      (prettier-js))

    (defun web-mode-sp-backward-unwrap-sexp ()
      (interactive)
      (pretify-afterwards 'sp-backward-unwrap-sexp))
    (defun web-mode-sp-unwrap-sexp ()
      (interactive)
      (pretify-afterwards 'sp-unwrap-sexp))
    (defun web-mode-sp-forward-slurp-sexp ()
      (interactive)
      (pretify-afterwards 'sp-forward-slurp-sexp))
    (defun web-mode-sp-backward-slurp-sexp ()
      (interactive)
      (pretify-afterwards 'sp-backward-slurp-sexp))
    (defun web-mode-sp-forward-barf-sexp ()
      (interactive)
      (pretify-afterwards 'sp-forward-barf-sexp))
    (defun web-mode-sp-backward-barf-sexp ()
      (interactive)
      (pretify-afterwards 'sp-backward-barf-sexp))
    (defun web-mode-sp-transpose-sexp ()
      (interactive)
      (pretify-afterwards 'sheesh-sp-transpose-sexp))
    (defun web-mode-sp-kill-sexp ()
      (interactive)
      (tagedit-kill))
    (defun web-mode-sp-split-sexp ()
      (interactive)
      (pretify-afterwards 'sp-split-sexp))
    (defun web-mode-sp-join-sexp ()
      (interactive)
      (pretify-afterwards 'sp-join-sexp))

    (add-hook 'web-mode-hook 'flycheck-mode)
    (add-hook 'web-mode-hook
              (lambda ()
                (run-sheesh-coding-hook)
                (setq web-mode-markup-indent-offset 2)
                (setq web-mode-css-indent-offset 2)
                (setq web-mode-code-indent-offset 2)

                (setup-cycle-quotes)

                ;; Auto indent on certain characters
                (local-set-key (kbd "}") #'(lambda ()
                                             (interactive)
                                             (insert "}")
                                             (indent-for-tab-command)))
                (local-set-key (kbd ";") #'(lambda ()
                                             (interactive)
                                             (insert ";")
                                             (indent-for-tab-command)))
                (set (make-local-variable 'comment-auto-fill-only-comments) nil)
                (auto-fill-mode t)

                (local-set-key (my-key "Unwrap previous sexp")
                               'web-mode-sp-backward-unwrap-sexp)
                (local-set-key (my-key "Unwrap next sexp")
                               'web-mode-sp-unwrap-sexp)
                (local-set-key (my-key "Slurp next sexp")
                               'web-mode-sp-forward-slurp-sexp)
                (local-set-key (my-key "Slurp previous sexp")
                               'web-mode-sp-backward-slurp-sexp)
                (local-set-key (my-key "Barf last sexp")
                               'web-mode-sp-forward-barf-sexp)
                (local-set-key (my-key "Barf first sexp")
                               'web-mode-sp-backward-barf-sexp)
                (local-set-key (my-key "Transpose previous and next sexp")
                               'web-mode-sheesh-sp-transpose-sexp)
                (local-set-key (my-key "Kill next sexp")
                               'web-mode-sp-kill-sexp)
                (local-set-key (my-key "Split (unGroup) sexp")
                               'web-mode-sp-split-sexp)
                (local-set-key (my-key "Join (Group) sexp")
                               'web-mode-sp-join-sexp)
                (bind-custom-tab-hydra
                 '(("e" . ( emmet-expand-line "Expand Line" "Emmet")))
                 "web-mode" web-mode-map )
                ))

    :init
    (setq web-mode-engines-alist
          '(("freemarker" . "\\.ftl\\'"))))

  ;; for better jsx syntax-highlighting in web-mode
  ;; - courtesy of Patrick @halbtuerke
  (defadvice web-mode-highlight-part (around tweak-jsx activate)
    (if (equal web-mode-content-type "jsx")
        (let ((web-mode-enable-part-face nil))
          ad-do-it)
      ad-do-it))
#+END_SRC

**** Tern in Web Mode

See [[Tern]].

**** Flycheck for Web Mode

See [[Spellchecking in JS]].

#+BEGIN_SRC emacs-lisp
(flycheck-add-mode 'javascript-eslint 'web-mode)
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
(add-hook 'css-mode-hook #'prettier-js-mode)
#+END_SRC

** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :mode ("\\.json$" . json-mode)
    :config
    (add-hook 'json-mode-hook 'run-sheesh-coding-hook)
    (setq-local flycheck-json-jsonlint-executable "jsonlint")
    (flycheck-add-mode 'json-jsonlint 'json-mode)
    (add-hook 'json-mode-hook 'flycheck-mode))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml$" . yaml-mode)
           ("\\.yaml$" . yaml-mode))
    :config
    (add-hook 'yaml-mode-hook 'run-sheesh-coding-hook)
    (add-hook 'yaml-mode-hook 'highlight-indent-guides-mode))
#+END_SRC

** Typescript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-ts-mode
    :mode (("\\.ts\\'" . typescript-ts-mode)
           ("\\.tsx\\'" . tsx-ts-mode))
    :init
    ;; Set indentation to 2 spaces
                                          ; (custom-set-variables
                                          ;  '(typescript-indent-level 2))

    :config
    (flycheck-add-mode 'javascript-eslint 'typescript-ts-mode)
    (flycheck-add-mode 'javascript-eslint 'tsx-ts-mode)

    (defhydra hydra-tsx-ts-mode (:hint nil :color blue)
      "Typescript"
      ("L" hydra-lsp-mode/body "LSP")

      ("c" hydra-combobulate/body "Combobulate" :column "Basic"   )
      ("e" tide-error-at-point "Error"          :column "Show"    )
      ("E" tide-project-errors "Project errors"                   )
      ("d" lsp-describe-thing-at-point "Doc at point"             )
      ("," lsp-find-references "References"                       )
      ("C-," lsp-find-references-window "References (buffer)"     ) 
      ("?" hydra-prog-mode-search/body "Search"                   )
      ("r" lsp-rename "Rename item"     :column "Refactor"        )
      ("F" lsp-javascript-rename-file "Rename file"               )
      ("i" lsp-organize-and-remove-unused-imports "Organize imports")
      ("." lsp-execute-code-action "Fix"                       :column "Do")

      ("s" sp-split-sexp "Split Group"              :column "Edit")
      ("j" sp-join-sexp "Join Group"                              )
      ("u" combobulate-splice-parent "Unmantle JSX"               )
      ("w" combobulate-envelop "Wrap"                             )
      ("R" combobulate-edit-cluster-dwim "Edit node cluster"      )
    ;;  ("t" tide-add-eslint-disable-next-line "ESLint disable"     )

      ("TAB" emmet-expand-line "Expand XML"        :column "Emmet"))

    ;; (defhydra hydra-tsx-ts-mode (:hint nil :color blue)
    ;;   "Typescript"
    ;;   ("X" tide-restart-server "Restart Tide"                     )
    ;;   ("c" hydra-combobulate/body "Combobulate" :column "Basic"   )
    ;;   ("e" tide-error-at-point "Error"          :column "Show"    )
    ;;   ("E" tide-project-errors "Project errors"                   )
    ;;   ("d" tide-documentation-at-point "Doc at point"             )
    ;;   ("," tide-references "References"                           )
    ;;   ("?" hydra-prog-mode-search/body "Search"                   )
    ;;   ("r" tide-rename-symbol "Rename item"     :column "Refactor")
    ;;   ("F" tide-rename-file "Rename file"                         )
    ;;   ("i" tide-organize-imports "Organize imports"               )
    ;;   ("." tide-fix "Fix"                       :column "Do"      )

    ;;   ("s" sp-split-sexp "Split Group"              :column "Edit")
    ;;   ("j" sp-join-sexp "Join Group"                              )
    ;;   ("u" combobulate-vanish-node "Unmantle JSX"                 )
    ;;   ("w" combobulate-envelop "Wrap"                             )
    ;;   ("R" combobulate-edit-cluster-dwim "Edit node cluster"      )
    ;;   ("t" tide-add-eslint-disable-next-line "ESLint disable"     )

    ;;   ("TAB" emmet-expand-line "Expand XML"        :column "Emmet"))



    ;; (use-package tide
    ;;   :ensure t
    ;;   :hook ((typescript-ts-mode . tide-setup)
    ;;          (tsx-ts-mode . tide-setup))
    ;;   :config
    ;;   (setq tide-always-show-documentation t)
    ;;   (setq company-tooltip-align-annotations t)
    ;;   (flycheck-add-next-checker 'tsx-tide 'javascript-eslint)
    ;;   ;; (setq flycheck-check-syntax-automatically '(save-mode-enabled))
    ;;   (add-hook
    ;;    'tide-mode-hook
    ;;    #'(lambda ()
    ;;        (eldoc-mode +1)
    ;;        (tide-hl-identifier-mode +1)
    ;;        (company-mode +1)
    ;;        (flycheck-mode +1)
    ;;        (flycheck-add-next-checker 'tsx-tide 'javascript-eslint 'append)
    ;;        (flycheck-add-next-checker 'typescript-tide 'javascript-eslint 'append))))


    (add-hook 'typescript-ts-mode-hook 'setup-ts-mode)
    (add-hook 'tsx-ts-mode-hook 'setup-ts-mode)

    (defun setup-ts-mode ()
      (run-sheesh-coding-hook)
      ;; (combobulate-mode)
      (flycheck-mode)
      (lsp-mode)
      (emmet-mode)
      (setup-cycle-quotes)
      (local-set-key (my-key "Mode hydra") 'hydra-tsx-ts-mode/body))


    (require 'ansi-color)
    (defun colorize-compilation-buffer ()
      (ansi-color-filter-region compilation-filter-start (point-max))
      ;; (ansi-color-apply-on-region compilation-filter-start (point-max)))
      )

    (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))

#+END_SRC

*** Flycheck for Web Mode

See [[Spellchecking in JS]].

#+BEGIN_SRC emacs-lisp
; (flycheck-add-mode 'javascript-eslint 'typescript-mode)
#+END_SRC

** Tailwind CSS

#+BEGIN_SRC emacs-lisp
  (use-package lsp-tailwindcss
    :after lsp-mode
    :ensure t
    :init
    (setq lsp-tailwindcss-add-on-mode t
          lsp-tailwindcss-skip-config-check t))
#+END_SRC

** SQL

#+BEGIN_SRC emacs-lisp
  (use-package sql-indent
    :ensure t)

  (defun sheesh-launch-sql-submodes ()
    (sqlind-minor-mode))

  (add-hook 'sql-mode-hook 'run-sheesh-coding-hook)
  (add-hook 'sql-mode-hook 'sheesh-launch-sql-submodes)
#+END_SRC

SQL LSP:
- https://bitspook.in/blog/using-org-mode-as-an-sql-playground/
  - For now, I had to use sqls as lsp-mode does not support
    https://github.com/joe-re/sql-language-server
  - Discussion: https://github.com/emacs-lsp/lsp-mode/discussions/3971

** Rust

Inspired by: https://robert.kra.hn/posts/rust-emacs-setup/
- Missing: Debugging section

*Prerequisites:*
#+BEGIN_SRC sh

yay -S rustup

rustup default stable
rustup component add rls
rustup component add rust-analyzer
rustup component add rust-src

# See below
sudo link $(rustup which --toolchain stable rust-analyzer) /usr/bin/rust-analyzer
#+END_SRC

Rustup seems to have an issue with rust-analyzer. It does not install
it into the correct folder or something so we have to manually create
a link (or extend the path variable). From the [[https://rust-analyzer.github.io/manual.html#rustup][docs]]:

#+BEGIN_EXAMPLE
rust-analyzer is available in rustup:

$ rustup component add rust-analyzer

However, in contrast to component add clippy or component add rustfmt, this does not actually place a rust-analyzer binary in ~/.cargo/bin, see this issue. You can find the path to the binary using:

$ rustup which --toolchain stable rust-analyzer

You can link to there from ~/.cargo/bin or configure your editor to use the full path.
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp
  (use-package rustic
      :ensure

      :config
      ;; uncomment for less flashiness
      ;; (setq lsp-eldoc-hook nil)
      ;; (setq lsp-enable-symbol-highlighting nil)
      ;; (setq lsp-signature-auto-activate nil)

      ;; comment to disable rustfmt on save
      (setq rustic-format-on-save t)
      (add-hook 'rustic-mode-hook 'rk/rustic-mode-hook)
      (add-hook 'rustic-mode-hook 'run-sheesh-coding-hook)

      :hydra
      (hydra-rust (:hint nil)
      "rust"
      ("j" lsp-ui-imenu "Menu")
      ("." lsp-find-references "Reference" :column "Code")
      ("l" flycheck-list-errors "List errors")
      ("a" lsp-execute-code-action "Code action")
      ("r" lsp-rename "Rename")
      ("q" lsp-workspace-restart "restart" :column "Server")
      ("Q" lsp-workspace-shutdown "shutdown")
      ("s" lsp-rust-analyzer-status "Analyzer status")
      ("R" rustic-cargo-run "Run")
      ("t" rustic-cargo-current-test "Run current test")
      ("?" hydra-prog-mode-search/body "Search" :color blue)))



    (defun rk/rustic-mode-hook ()
      ;; so that run C-c C-c C-r works without having to confirm, but don't try to
      ;; save rust buffers that are not file visiting. Once
      ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
      ;; no longer be necessary.
      (when buffer-file-name
        (setq-local buffer-save-without-query t))
      (add-hook 'before-save-hook 'lsp-format-buffer nil t)
      (local-set-key (my-key "Mode hydra") 'hydra-rust/body))
#+END_SRC

** Terraform

#+BEGIN_SRC emacs-lisp
  ;; (use-package hcl-mode
  ;;   :ensure t
  ;;   :mode ("\\.tf?\\'" . hcl-mode)
  ;;   :config
  ;;   (add-hook 'hcl-mode-hook 'run-sheesh-coding-hook))


  (use-package terraform-mode
      :ensure t
      :custom
      (terraform-format-on-save t)
      :config
      (add-hook 'terraform-mode-hook 'run-sheesh-coding-hook)
      (add-hook 'terraform-mode-hook
                (lambda ()
                  (local-set-key (my-key "Mode hydra") 'hydra-terraform/body)
                  (lsp-mode)))
      :hydra
      (hydra-terraform (:hint nil)
                       "terraform"
        ("L" hydra-lsp-mode/body "LSP")
        ("j" lsp-ui-imenu "Menu")
        ("." lsp-execute-code-action "Fix" :column "Do")
        ("r" lsp-rename "Rename")
        ("R" terraform-format-buffer "Format buffer")
        ("," lsp-find-references "Reference" :column "Show")
        ("C-," lsp-find-references-window "References (buffer)"     ) 
        ("M-." xref-find-definitions-other-window "Goto Definition (other buf)")
        ("d" terraform-open-doc "Open Doc for Block")
        ("l" flycheck-list-errors "List errors")
        ("?" hydra-prog-mode-search/body "Search" :color blue)))
#+END_SRC

** C Sharp
Requires [[https://csharpier.com/][CSharpier]] to do the prettification. Install it like this:

#+BEGIN_SRC sh
dotnet tool install csharpier -g
#+END_SRC


#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.cs\\'" . csharp-ts-mode))
    (defun lsp-find-references-window ()
      (interactive)
      (let ((old-xref-show-xrefs-function xref-show-xrefs-function))
        (setq xref-show-xrefs-function 'xref--show-xref-buffer)
        (lsp-find-references)
        (setq xref-show-xrefs-function old-xref-show-xrefs-function)
        ))
    (defhydra hydra-csharp-ts-mode (:hint nil :color blue)
      "C#"
      ("L" hydra-lsp-mode/body "LSP")
      ("c" hydra-combobulate/body "Combobulate"         :column "Basic")
      ("E" lsp-treemacs-errors-list "Project errors"    :column "Show")
      ("d" lsp-describe-thing-at-point "Doc at point")
      ("?" hydra-prog-mode-search/body "Search")

      ("M-." xref-find-definitions-other-window "Goto Definition (other buf)")
      ("," lsp-find-references "References")
      ("C-," lsp-find-references-window "References (buffer)") 
      ("r" lsp-rename "Rename item"                     :column "Refactor")
      ("P" lsp-format-buffer "Prettify buffer")
      ("p" lsp-format-region "Prettify region")
      ("." lsp-execute-code-action "Fix"                :column "Edit")
      ("s" sp-split-sexp "Split Group")
      ("j" sp-join-sexp "Join Group")

      ("TAB" hydra-copilot/body "Copilot"))
    :init
    (add-hook 'csharp-ts-mode-hook #'company-mode)
    (add-hook 'csharp-ts-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'csharp-ts-mode-hook #'lsp)
    (add-hook 'csharp-ts-mode-hook 'run-sheesh-coding-hook)
    (add-hook 'csharp-ts-mode-hook 'flycheck-mode)
    (defun setup-csharp-mode ()
      (local-set-key (my-key "Mode hydra") 'hydra-csharp-ts-mode/body)
      (local-unset-key (my-key "Go 3 lines forward"))
      (local-unset-key (my-key "Go 3 lines backward"))


      ;; disable lsp-ui-sideline-mode ?

      (setq comment-insert-comment-function (lambda ()
                                              (indent-according-to-mode)
                                              (insert "/*  */")
                                              (backward-char 3)))

      (set (make-local-variable 'prettier-js-command)
           (expand-file-name "csharp-prettier" user-emacs-directory))
      (set (make-local-variable 'prettier-js-args) '())
      (prettier-js-mode))
    (add-hook 'csharp-ts-mode-hook 'setup-csharp-mode))

#+END_SRC

*** Unity

Install https://github.com/elizagamedev/rider2emacs and set the unity
editor to that.

Then start the emacs server using =M-x server-start=.

Not tested, but maybe useful: https://github.com/elizagamedev/unity.el

** XML

#+BEGIN_SRC emacs-lisp
  (use-package xml-mode
        :mode
        (("\\.xml$" . xml-mode)
         ("\\.csproj$" . xml-mode)))
#+END_SRC

** KDL Config files

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.kdl\\'" . (lambda ()
                                 (conf-mode)
                                 (setq-local comment-start "//")
                                 (setq-local comment-end   ""))))
#+END_SRC

** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure t
    :config
    (add-hook 'groovy-mode-hook 'run-sheesh-coding-hook))
#+END_SRC

** GLSL

#+BEGIN_SRC emacs-lisp
  (use-package glsl-mode
    :ensure t
    :config
    (add-hook 'glsl-mode-hook 'run-sheesh-coding-hook))
#+END_SRC
